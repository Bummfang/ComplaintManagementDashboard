// app/api/admin/create-user/route.ts
import { NextResponse, type NextRequest } from 'next/server';
import { type PoolClient } from 'pg';
import { getDbPool } from '@/lib/db'; // Pfad ggf. anpassen
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

interface CreateUserRequestBody {
  name?: string;
  nachname?: string;
  password_hash?: string; // Frontend sendet hier das Klartext-Passwort
  isAdmin?: boolean;
}

interface UserRecord {
  id: number;
  username: string; // Wird von der DB generiert und hier zurückgegeben
  name: string;
  nachname: string;
  ist_admin: boolean;
}

const JWT_SECRET = process.env.JWT_SECRET;

export async function POST(request: NextRequest) {
  const requestTimestamp = new Date().toISOString();
  console.log(`[${requestTimestamp}] API POST /api/admin/create-user: Attempt to create new user.`);

  if (!JWT_SECRET) {
    console.error(`[${new Date().toISOString()}] FATAL for /api/admin/create-user: JWT_SECRET is not defined.`);
    return NextResponse.json({ error: 'Serverkonfigurationsfehler.', details: 'JWT Secret nicht konfiguriert.' }, { status: 500 });
  }

  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return NextResponse.json({ error: 'Authentifizierungstoken fehlt oder ist ungültig.' }, { status: 401 });
  }
  const token = authHeader.split(' ')[1];

  try {
    const decodedToken = jwt.verify(token, JWT_SECRET) as { userId: number; username: string; isAdmin: boolean };
    if (!decodedToken.isAdmin) {
      return NextResponse.json({ error: 'Zugriff verweigert.', details: 'Nur Administratoren können Benutzer anlegen.' }, { status: 403 });
    }
  } catch (error) {
    return NextResponse.json({ error: 'Ungültiges oder abgelaufenes Token.', details: error instanceof Error ? error.message : 'JWT error' }, { status: 401 });
  }

  let body: CreateUserRequestBody;
  try {
    body = await request.json();
  } catch (e) {
    return NextResponse.json({ error: 'Ungültiger JSON-Body.' }, { status: 400 });
  }

  const { name, nachname, password_hash: plainPassword, isAdmin } = body;

  if (!name || !nachname || !plainPassword) {
    return NextResponse.json({ error: 'Vorname, Nachname und Passwort sind erforderlich.' }, { status: 400 });
  }
  if (plainPassword.length < 6) {
    return NextResponse.json({ error: 'Das Passwort muss mindestens 6 Zeichen lang sein.' }, { status: 400 });
  }
  if (typeof isAdmin !== 'boolean') {
    return NextResponse.json({ error: "Das Feld 'isAdmin' muss ein Boolean sein." }, { status: 400 });
  }

  // Der Benutzername wird von der Datenbank generiert.
  // Die API generiert ihn NICHT mehr und versucht auch nicht, ihn auf Eindeutigkeit zu prüfen.
  // Die Eindeutigkeit wird durch einen UNIQUE Constraint in der DB sichergestellt.

  const pool = getDbPool();
  let client: PoolClient | undefined;

  try {
    client = await pool.connect();

    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);

    // KORRIGIERT: `username` aus der INSERT-Liste entfernt.
    // Parameter sind jetzt $1, $2, $3, $4
    const insertUserQuery = `
      INSERT INTO users (name, nachname, password, ist_admin)
      VALUES ($1, $2, $3, $4)
      RETURNING id, username, name, nachname, ist_admin;
    `;
    // KORRIGIERT: Parameterliste angepasst (kein username mehr)
    const result = await client.query<UserRecord>(insertUserQuery, [
      name.trim(),      // $1
      nachname.trim(),  // $2
      hashedPassword,   // $3
      isAdmin,          // $4
    ]);

    if (result.rows.length === 0) {
      throw new Error('Benutzer konnte nicht in der Datenbank erstellt werden (keine Zeile zurückgegeben).');
    }

    const newUser = result.rows[0];
    console.log(`[${new Date().toISOString()}] User "${newUser.username}" (ID: ${newUser.id}, Admin: ${newUser.ist_admin}) successfully created by database generation.`);

    return NextResponse.json(
      {
        userId: newUser.id,
        username: newUser.username, // Dieser Wert kommt jetzt direkt aus der DB
        name: newUser.name,
        nachname: newUser.nachname,
        isAdmin: newUser.ist_admin,
        message: 'Benutzer erfolgreich angelegt.',
      },
      { status: 201 }
    );

  } catch (error: any) {
    const errorTimestamp = new Date().toISOString();
    // Fehlercode für UNIQUE-Verletzung in PostgreSQL
    if (error.code === '23505' && error.constraint && error.constraint.includes('username')) {
      console.warn(`[${errorTimestamp}] Failed to create user due to duplicate username (generated by DB). Original name: ${name} ${nachname}. DB Error: ${error.detail || error.message}`);
      return NextResponse.json({ error: 'Benutzername (automatisch generiert) existiert bereits.', details: 'Versuchen Sie eine andere Kombination von Vor-/Nachname oder kontaktieren Sie den Support, falls das Problem bestehen bleibt.' }, { status: 409 });
    }

    console.error(`[${errorTimestamp}] Error during user creation process:`, error);
    let errorMessage = 'Ein interner Serverfehler ist aufgetreten.';
    let errorDetails = 'Unbekannter Fehler';
    if (error instanceof Error) {
      errorDetails = error.message;
      if (error.message.includes('ECONNREFUSED')) {
        errorMessage = 'Datenbankverbindung fehlgeschlagen.';
      }
    }
    return NextResponse.json({ error: errorMessage, details: errorDetails }, { status: 500 });
  } finally {
    if (client) {
      client.release();
    }
  }
}